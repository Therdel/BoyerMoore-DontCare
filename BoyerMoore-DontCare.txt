Case 1: Wildcards in middle
Needle		krak_tat
Needle		kra__tat

BadChar:	A wildcard can be in between any next known or unknown character.
			Any mismatching character will fall into the nearest wildcard pit, unless a matching position stands in between
			Mismatch non-existing Character: nearest wildcard to the left
				Usual array lookup for indexList won't work: All characters will match the nearest wildcard.
				Option: Lookup array for 
				
			Option: Table that answers all possible characters at every position.
				- 
			Idea: Matching on DontCare Fields.
				Option A: BadChar could respond the amount of DontCare positions to skip checking to the algorithm
				Option B: The algorithm could do that itself, too and don't ask its other rules then.
					--> Preprocess DontCare regions, skip over them.
					--> Would result BadChar/GoodSuffix Rules only having to answer to mismatches on true pattern characters.
			--> Rules, like in OG BM, shouldn't be asked when a match occurs, anyway.
			--> Rules don't have to prepare for matching agains DontCare.
			Mismatch after all wildcards: Business as usual
			(No mismatches inside wildcards & badchar won't get called on wildcard pos)
GoodSuffix:	same as orig: 'tat' could match inside the wildcards. Same Nj strategy as gusfield.
AfterMatch: same as orig: Biggest prefix/suffix align
Algorithm:

-> Option: Match all non-wildcard areas on their own
	?downside: does it take advantage of shifting?

Case 2: Multiple Wildcard fields in middle
Needle		kr_k_tat
Needle		k__k__at


Case 2: Wildcard(s) in Front
Needle		_rakotat
Needle		__akotat

Case 3: Wildcard in Back
Needle		krakota_
Needle		krakot__

Case 4..?: Mixed



Pos			76543210

index				0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	22	23	24	25
letter				a	b	c	d	e	f	g	h	i	j	k	l	m	n	o	p	q	r	s	t	u	v	w	x	y	z